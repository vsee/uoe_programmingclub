\documentclass{article}

\usepackage{amsmath}
\usepackage[margin=1cm]{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{minted}

\title{
    \textbf{Programming Club}\\
    Fractals
}
\author{Hugh Leather}
\date{10$^{th}$ January 2018}

\begin{document}
    \maketitle

    \section{Output to a file} 
    
        We are going to draw our pictures into files. That means that first we need to be able to write into a file. 
        \paragraph{Task: ``Hello, File!''}
            Try to write a program to print ``\texttt{Hello, File!}'' to a file called \texttt{hello.txt}.

            Below we'll look at all the bits you will need, step by step. At each step, try to work it out yourself first, making use of
            the online documentation, using these notes only if you need to.
        
        \paragraph{\texttt{PrintStream}}
            
            Fortunately, in Java, writing to files is pretty easy. You will probably want to look at the package documentation for the
            \texttt{java.io} package at some point
            (\url{https://docs.oracle.com/javase/8/docs/api/index.html?java/io/package-summary.html}).
     
            The idea is that we create a \texttt{PrintStream}\footnote{It would probably be a bit more modern to use a
            \texttt{PrintWriter}.} which has operations like \texttt{println} that print text to a file. You have probably already seen a
            \texttt{PrintStream} when you use \texttt{System.out.println}. In that code, \texttt{System.out} is a \texttt{PrintStream} that
            prints to the standard output.
        
        \paragraph{A main class.} 
        
            You will have to write a Java class. Let's call it \texttt{FileOutputTest}. This is going to be a public class (the public bit
            just means everyone can see it). In Java, any top level public class needs to go in a file of the same name with a
            \texttt{.java} extension. So, we'll put the class in file \texttt{FileOutputTest.java}.
            
            This file is just going to have a \texttt{main} method which will be called when we run the program. We'll add more to it later.
            
            \begin{minted}[autogobble]{Java}
                public class FileOutputTest {
                    public static void main(String[] args) {
                        System.out.println("Hello, World!")
                    }
                }
            \end{minted}
        
            For now, you should be able to compile this class with:
            \begin{minted}[autogobble]{Bash}
                javac FileOutputTest.java
            \end{minted}
            
            And then run it with:
            \begin{minted}[autogobble]{Bash}
                java FileOutputTest
            \end{minted}
        
            If all has gone well, it should print ``\texttt{Hello, World!}''
            
        \paragraph{Print to a file instead.}
            
            To print to a file, you need to create a new \texttt{PrintStream}. You can do this by adding this to your \texttt{main} method:
            \begin{minted}[autogobble]{Java}
                java.io.PrintStream ps = new java.io.PrintStream("hello.txt");
            \end{minted}
            Just a quick note: if you are using Java 10, you can just write 
            \begin{minted}[autogobble]{Java}
                var ps = new java.io.PrintStream("hello.txt");
            \end{minted}
            
            Now you can print to that stream:
            \begin{minted}[autogobble]{Java}
                ps.println("Hello, File!");
            \end{minted}
            
            When you're finished with the file you have to close it, otherwise not all the text may get written:
            \begin{minted}[autogobble]{Java}
                ps.close();
            \end{minted}
            
        \paragraph{Exceptions.}

            But, if you try to compile this, it won't work. It will complain that \texttt{FileNotFoundException} has not been handled. Java
            is quite picky about somethings. In this case it is saying that \texttt{new java.io.PrintStream("hello.txt")} can fail and
            someone had better agree to do something about it.

            There are several ways we can fix this. The first is to say, hey someone else can deal with it. This means that it will be the
            problem of whoever calls \texttt{main}. This is okay, the \texttt{java} program will report the exception if it gets it.
            To do this, we say that \texttt{main} might throw this exception out. Then Java is happy again and we can compile it.
            \begin{minted}[autogobble]{Java}
                public static void main(String[] args) throws FileNotFoundException {
            \end{minted}
             
            A better way is to catch the error do something sensible about it using a \texttt{try} and \texttt{catch}.
             
            Even better is to use \texttt{try} with resource.
             
             We might come back to those another time.
        
        \paragraph{Imports} 
            When you use \texttt{PrintStream}, you have to either use its full name (\texttt{java.io.PrintStream}), or you can import that
            name so that thereafter you can just use \texttt{PrintStream} by itself. At the top of your Java file, you can write this to
            import the name.
        
            \begin{minted}[autogobble]{Java}
                import java.io.PrintStream;
            \end{minted}
        
            But, we're probably going to use several names from that package, so we can bring them all in at once by using this import:
            \begin{minted}[autogobble]{Java}
                import java.io.*;
            \end{minted}
        
        \paragraph{The final code}
            This should be what we end up with:
            
            \begin{minted}[autogobble]{Java}
                import java.io.*;
                public class FileOutputTest {
                    public static void main(String[] args) throws FileNotFoundException {
                        PrintStream ps = new PrintStream("hello.txt");
                        ps.println("Hello, File!");
                        ps.close();
                    }
                }
            \end{minted}
        
            Compile it, run it, and check that it writes to \texttt{hello.txt}.

    \section{A first picture}
     
        The simplest picture format you might use is PPM. You can write out the image to a file in this format and then view it on your
        desktop. There several different PPM types, but the easiest for us is P3, which will allow everything to be written in text, rather
        than binary. It lets us build up pixels of red, green, and blue components quite simply.
        
        \paragraph{P3 format}
            The basic structure of the file is like this:
        
            \begin{minted}[autogobble]{Java}
                P3
                <width> <height>
                <max>
                <r> <b> <g>   <r> <b> <g>  <r> <b> <g> ...
                <r> <b> <g>   <r> <b> <g>  <r> <b> <g> ...            
            \end{minted}

            All of these numbers are given as ordinary decimals. The \texttt{width} and \texttt{height} are the number of pixels wide and
            high the image is. \texttt{max} is the largest value any of red, green, and blue could take. I.e. fully on. A simple value for
            this is 255, which will work for bytes and give you $2^24$ different colours. Each of \texttt{r}, \texttt{g}, and \texttt{b}
            are values between 0 and \texttt{max} inclusive, giving the amount of that colour for the appropriate pixel. The pixels are
            arranged so that the rows are done first, with the very first pixel being the top left of the image.
        
            Between each element of the file, there has to be some whitespace. These can be any number of spaces, tabs, or newlines.
            \textbf{The last character of the file has to be whitespace!}
        
        \paragraph{Task: Make a heart}
            
            Since Valentine's day is coming soon, make a very small image, just using your text editor.  It should look like this:

                \includegraphics[width=0.5\textwidth]{code/heart.jpg}
        
            I admit, it's not a very good heart.
            
        \paragraph{The heart file}
            Here's what the file should look like.  Remember to have some whitespace at the very end.
            \begin{minted}[autogobble]{Java}
                P3
                5 4
                255
                0 0 0       255 0 0     0 0 0       255 0 0     0 0 0 
                255 0 0     255 0 0     255 0 0     255 0 0     255 0 0
                0 0 0       255 0 0     255 0 0     255 0 0     0 0 0
                0 0 0       0 0 0       255 0 0     0 0 0       0 0 0
            \end{minted}            

        \paragraph{Task: A Java heart}
            Use Java to write out the heart file instead.  
            
            Add two static variables for the height and width of the picture. Add three arrays of \texttt{float}s for the red, green, and
            blue pixels (we'll use \texttt{0.0} for black and \texttt{1.0} for fully read, green, or blue). Add a function to convert from
            a \texttt{float} between \texttt{0.0} and \texttt{1.0} into an integer between 0 and 255. Add a function to write the image to
            a file. Write it.
        
        \paragraph{Adding some variables}
            Let's make a new class and add some variables to it.  Put this code into \texttt{Heart.java}.
            
            Note that all the variables are \texttt{static}.  This makes them available from \texttt{static} methods like main.
            
            Also, we could have used a multidimensional array for each of the colours, but this works as well. You have to convert though
            from your \texttt{x} and \texttt{y} coordinates into a single index.
            
            \begin{minted}[autogobble]{Java}
                import java.io.*;
                
                public class Heart {
                    static int width = 5;
                    static int height = 4;
                    
                    static float[] red = new float[width * height];
                    static float[] green = new float[width * height];
                    static float[] blue = new float[width * height];
                    
                    public static void main(String[] args) {
                    }
                }
            \end{minted}
        \newpage
        \paragraph{Setting a pixel}
            Let's add a function to set the value of a pixel.

            Note that we convert x and y to an index - we should probably do some bounds checking there, eh?

            \begin{minted}[autogobble]{Java}
                static void set(int x, int y, float r, float g, float b) {
                    int i = x + y * width;
                    red[i] = r;
                    green[i] = g;
                    blue[i] = b;
                }
            \end{minted}
        
        \paragraph{Convert a channel value to an \texttt{int}}
            Converting channels (i.e. values of red, green, or blue pixels) into integers for the file isn't too bad.  
            
            We want \texttt{0.0} to map to \texttt{0}.
            
            We want \texttt{1.0} to map to \texttt{255}.
            
            We want an even spread between.
            
            So this equation will do:\footnote{Actually this isn't quite right since really we want the interval $(1-\epsilon,1]$ to map to 255. What would $\epsilon$ be? How would you change the rest?} 
            $colour \rightarrow colour \times 255$
            
            \begin{minted}[autogobble]{Java}
                static int colourToInt(float c) {
                    return (int)(c * 255);
                }
            \end{minted}

            Now you will notice that there is a bit in there which ``casts to an int''. That is because Java complains if you try to
            convert from one type to another where you might lose information.  The cast says that this really is what you want.
            
        \paragraph{Writing out an image}
            Let's add a method called \texttt{write} to dump the image to a file.  It should take a file name as a string.
            
            Note that this code might throw and exception, so we need to let anyone using it know that.
            
            \begin{minted}[autogobble]{Java} 
                static void write(String fileName) throws FileNotFoundException {
                    PrintStream ps = new PrintStream(fileName);
                    ps.println("P3");
                    ps.println(width + " " + height);
                    ps.println(255);
                    
                    for(int i = 0; i < width * height; ++i) {
                        ps.print(colourToInt(red[i]) + " ");
                        ps.print(colourToInt(green[i]) + " ");
                        ps.print(colourToInt(blue[i]) + " ");
                    }
                    
                    ps.close();
                }
            \end{minted}
        
        \newpage
        \paragraph{Making the heart}
            Let's fill up the pixels in the \texttt{main} method and then write out the file.
            
            Note that the array values are filled with zeros to start with, so we only have to set the red pixels.
            
            \begin{minted}[autogobble]{Java}
                public static void main(String[] args) throws FileNotFoundException {
                    // Set the pixels
                    set(1,0, 1,0,0);
                    set(3,0, 1,0,0);
                    
                    set(0,1, 1,0,0);
                    set(1,1, 1,0,0);
                    set(2,1, 1,0,0);
                    set(3,1, 1,0,0);
                    set(4,1, 1,0,0);
                    
                    set(1,2, 1,0,0);
                    set(2,2, 1,0,0);
                    set(3,2, 1,0,0);
                    
                    set(2,3, 1,0,0);
                    
                    // Write out the file
                    write("heart-from-java.ppm");
                }
            \end{minted}

    \newpage
    \section{A smooth image}
        See if you can make an image, 200 by 100 pixels, that looks like this:
        
        \includegraphics{code/smooth.jpg}
        
        \paragraph{Looping over the pixels}
            This might look pretty easy, but there's a little trap waiting for you, which we'll get to in a bit.
            
            First of all copy the previous code into a new file and change the class name.  Maybe \texttt{Smooth.java} and \texttt{Smooth}
            respectively.
            
            Then you'll need to change the width and height of the image:
            \begin{minted}[autogobble]{Java}
                import java.io.*;
                
                public class Smooth {
                    static int width = 200;
                    static int height = 100;
                    //...
            \end{minted}
            
            Now we replace the main method which builds the image (including sending it to a different file). We'll make a couple of
            \texttt{for} loops. The first will iterate over the \texttt{x} axis, the second will iterate over the \texttt{y} axis.

            \begin{minted}[autogobble]{Java}
                public static void main(String[] args) throws FileNotFoundException {
                    for(int x = 0; x < width; ++x) {
                        for(int y = 0; y < height; ++y) {
                            // Set the colour for (x, y) here
                        }
                    }
                    // Write out the file
                    write("smooth.ppm");
                    
                }
            \end{minted}
        
            How do you set the colour for \texttt{(x, y)}? Well, you want the \texttt{x} axis to change the red channel from 0 to 1, and
            the \texttt{y} axis to change the blue channel from 0 to 1. So it should look like this, right?
            
            \begin{minted}[autogobble]{Java}
                set(x,y, x/width,0,y/height);
            \end{minted}
            
            Try it. What happens?
        
        \paragraph{Watch out for integer division}
            Hmm, the last thing made an image of the right size, but all the pixels were black.  What went wrong?
            
            Well, if you look at the types of \texttt{x} and \texttt{width}, you will see they are both integers. Integer division rounds
            down, so instead of a number between \texttt{0.0} and \texttt{1.0}, you get \texttt{0}. Then that is converted from an integer
            version of zero to floating point version of zero - i.e. \texttt{0.0}.
            
            What we need to do is to tell Java that we really want to do this with floating point division, not integer division. 
            
            The easy way is to tell it that one of the numbers is a \texttt{float}:
            \begin{minted}[autogobble]{Java}
                set(x,y, x/(float)width,0,y/(float)height);
            \end{minted}
            
            Phew, now everything works.

    \newpage
    \section{An Image Object}
    
        So this code that we've written is okay. But it's a bit painful to use. Each time you need a new picture you have to make a new
        class file for the image. And, you have to manually copy over all the \texttt{width} and \texttt{height} fields, as well as the
        methods we wanted, like \texttt{set} and \texttt{write}. It is hardly ideal, is it?
        
        I guess what we'd like is to be able to have lots of images kicking around all at once, but have them share most of the
        functionality. Java makes this easy by giving us objects.
        
        With the \texttt{static} fields in the classes we've made, there is only one copy per class. With objects, there is a copy per
        object, and you make as many objects as you like, even inside a loop. In fact, Java expects you to use objects so much that they
        are the default, you have to mention if something is static specifically.
        
        \paragraph{Make an Image class.}
            Try to work out how to do this yourself!
            
        \paragraph{Okay, I'll show you :-)}
            %
            First, let's make a new Java file for our class. We'll call it \texttt{Image.java}. 
            
            Copy in everything from the other files except the \texttt{main} method and don't use the word \texttt{static}. Non static
            things belong to a particular object.
            
            In fact, wherever you had \texttt{static}, use the word \texttt{public}. This means that Java will let you use that name from
            outside the object. I think Volker is going to discuss both \texttt{static} and \texttt{public} in Inf1OP at some point, so I
            won't go into them in much detail.

            \begin{minted}[autogobble]{Java}
                import java.io.*;

                public class Image {
                    public int width;
                    public int height;
    
                    public float[] red = new float[width * height];
                    public float[] green = new float[width * height];
                    public float[] blue = new float[width * height];    

                    public void set(int x, int y, float r, float g, float b) {
                        int i = x + y * width;
                        red[i] = r;
                        green[i] = g;
                        blue[i] = b;
                    }

                    public int colourToInt(float c) {
                        return (int)(c * 255);
                    }
                    public void write(String fileName) throws FileNotFoundException {
                        PrintStream ps = new PrintStream(fileName);
                        ps.println("P3");
                        ps.println(width + " " + height);
                        ps.println(255);
        
                        for(int i = 0; i < width * height; ++i) {
                            ps.print(colourToInt(red[i]) + " ");
                            ps.print(colourToInt(green[i]) + " ");
                            ps.print(colourToInt(blue[i]) + " ");
                        }
        
                        ps.close();
                    }
                    
                }
            \end{minted}
        
        \newpage
        \paragraph{Make a new image}
            %
            So now we we can make as many images as we want. But how do we use them?
            
            Let's make the \emph{smooth} image using our object class.  We'll put it in class \texttt{SmoothObj}
            
            To make a new object, use \texttt{new}.  For the image, we would use:

            \begin{minted}[autogobble]{Java}
                Image img = new Image();
            \end{minted}
            
            Now wherever previously you used a static variable or method, call \texttt{img}'s version instead.     
            
            \begin{minted}[autogobble]{Java}
                import java.io.*;

                public class SmoothObj {

                    public static void main(String[] args) throws FileNotFoundException {
                        Image img = new Image();
                        img.width = 200;
                        img.height = 100;
                        
                        // Set the pixels
                        for(int x = 0; x < img.width; ++x) {
                            for(int y = 0; y < img.height; ++y) {
                                img.set(x,y, x/(float)img.width,0,y/(float)img.height);
                            }
                        }
                        // Write out the file
                        img.write("smooth.ppm");
                    }
                }
            \end{minted}
                    
            You could now have as many images as you'd like.
            
            Eeek, this didn't work!  Why not?

        \paragraph{An image constructor}
            %
            When you made a new new \texttt{Image}, did you notice that there were parentheses after \texttt{Image}? This might be a bit
            suggestive to you that maybe you could put function parameters there.  Well, yes, you can.
            
            We currently have to tell Java after we constructed the \texttt{Image} what it's width and height are.  That could be dangerous.
            
            In fact, it was dangerous for us! You may have noticed that you got an \texttt{java.lang.ArrayIndexOutOfBoundsException} when
            running the previous code. The reason for this is that we didn't set the \texttt{Image}'s \texttt{width} or \texttt{height}
            before making the arrays for \texttt{red}, \texttt{green}, and \texttt{blue}. In java, when you don't initialise a field, it is
            set to \texttt{0}, if it's a number, or \texttt{null} if it's an object. So, \texttt{width} and \texttt{height} were both zero
            when the arrays were created. Then, when we tried to set a pixel, the index we chose `fell off' the end of the array.
            
            By using constructors and then not letting other people access critical bits of a class, we can make sure that things are
            always in a good state. A constructor is an object method with special name, the same name as the class. Also, it doesn't
            return anything, you can only call it during \texttt{new}, and there are some other rules about what they have to do which we
            won't worry about just now.
            
            Let's make a constructor for our \texttt{Image} class that takes the \texttt{width} and \texttt{height}, and then creates the
            arrays for the colours.
            
            \begin{minted}[autogobble]{Java}
                public class Image {
                    public int width;
                    public int height;
    
                    public float[] red;
                    public float[] green;
                    public float[] blue;    
            
                    public Image(int w, int h) {
                        width = w;
                        height = h;
                        red = new float[width * height];
                        green = new float[width * height];
                        blue = new float[width * height];
                    }
                    ...
            \end{minted}
            
            Great! But now the \texttt{new} call in \texttt{SmoothObj} doesn't work because we don't have a constructor which takes no
            arguments.  Let's change that.
            
            \begin{minted}[autogobble]{Java}
                import java.io.*;

                public class SmoothObj {

                    public static void main(String[] args) throws FileNotFoundException {
                        Image img = new Image(200, 100);
                        
                        // Set the pixels
                        for(int x = 0; x < img.width; ++x) {
                            for(int y = 0; y < img.height; ++y) {
                                img.set(x,y, x/(float)img.width,0,y/(float)img.height);
                            }
                        }
                        // Write out the file
                        img.write("smooth.ppm");
                    }
                }
            \end{minted}
        
        \paragraph{Finally secure}
            %
            BTW, the things we're doing here, up until we talk about Mandelbrots, are just to make things better and to show you more Java.
            If you want to just get on with the pretty pictures, you could skip ahead to Mandelbrots and try to make things work like that.
            
            So, we have a constructor, but we still aren't entirely safe. What if someone changes the \texttt{width} after they've made the
            image? Well, then all hell could break loose. Maybe we should stop them doing that.
            
            In Java, there is a simple way to stop that. We can tell Java that once a field is initialised then it can't ever be changed
            again. We do that with the \texttt{final} keyword.

            \begin{minted}[autogobble]{Java}
                public class Image {
                    public final int width;
                    public final int height;
    
                    public final float[] red;
                    public final float[] green;
                    public final float[] blue;    
            \end{minted}
            
            Do that and see what happens if you try to change \texttt{width}, say by adding one to it.
            
        \paragraph{Complaining about crazy people}
            %
            Okay, so we've protected against crazy people trying to mess with things in the wrong order, but we still aren't safe. What
            would happen if someone used a negative \texttt{width} for the \texttt{Image}? Or what if someone tries to set the pixel at
            \texttt{(-100,5000)}? What if they use colour values outside of the range \texttt{0.0} to \texttt{1.0}? They would probably
            make the universe explode (try it?).
            
            Maybe we should check for this bad things and report something sensible to the user. What we will do is throw an exception.
            That means we tell Java to stop what it's doing and report a problem that someone has to fix or the stop the program if no one
            does. We've already seen that making a \texttt{PrintStream} can throw a \texttt{FileNotFoundException}. It is just like that,
            except for two things. 1) we will throw an \texttt{IllegalArgumentException} instead. 2) Java isn't as persnickety about that
            exception, so we don't need to add it to the list in \texttt{main}, or anywhere else. \footnote{Java has two types of exception. One has
            to be handled or the compiler won't compile your program. They other type (called a \texttt{RuntimeException}) doesn't. It's an
            historical thing, mostly, and not a little bit annoying.}
            
            \begin{minted}[autogobble]{Java}
                public Image(int w, int h) {
                    if(w <= 0) throw new IllegalArgumentException("width must be > 0");
                    if(h <= 0) throw new IllegalArgumentException("width must be > 0");
                    //...
            \end{minted}
            
            Now, if someone tries to make a badly sized image, they will get a nice error about it.  Try it.
            
            Can you make anything else in the \texttt{Image} class safe this way?
            
    \newpage
    \section{Objects, Objects, Everywhere!}
        
        Objects are kind of useful in Java.  They let us make lots of things easier and more natural. Let's turn our attention to colours.
        
        \paragraph{Colour}
            %
            So far, we've been using three separate colour channels to represent our three colours. This means you can't define a constant
            for mauve, say, and then pass it into the \texttt{set} method on the image. You still have to put in the three colours
            individually. It would be much better if we had an idea of a colour object instead that encapsulated the three colour channels
            for us.
        
            So, let's create a \texttt{Colour} class.  What do you think it should look like?
        
            Let's put it in \texttt{Colour.java}.  

            \begin{minted}[autogobble]{Java}
                public class Colour {
                    public final float r, g, b;
                
                    public Colour(float r, float g, float b) {
                        this.r = r;
                        this.g = g;
                        this.b = b;
                    }
                }
            \end{minted}
        
            Now, you might notice that there's a special name used here, \texttt{this}. It refers to the current object. You can imagine
            that there is an extra parameter to a non \texttt{static} method, called \texttt{this} that points to the current object. In
            fact, under the covers, this is exactly what Java does.

            \begin{minted}[autogobble]{Java}                
                public Colour(Colour this, float r, float g, float b)
            \end{minted}
        
            So, now, when we refer to \texttt{this.r}, it means the \texttt{r} belonging to the object itself, not the \texttt{r} passed in.
            This is great because it means we can have the same name appear twice without getting confused.
        
            Oh, notice that we made the \texttt{r}, \texttt{b}, \texttt{g} fields of the \texttt{Colour} object all \texttt{final}. This
            means that \texttt{Colour}s are \emph{immutable}. Immutable objects are a bit safer since they are harder to mess up. Consider
            if we added some \texttt{static} fields into the \texttt{Colour} class for common colours.
        
            \begin{minted}[autogobble]{Java}
                public class Colour {
                    ...
                    public static final Colour BLACK = new Colour(0,0,0);
                    public static final Colour WHITE = new Colour(1,1,1);
                    public static final Colour RED = new Colour(1,0,0);
                    ...
                }
            \end{minted}
        
            Notice we made those fields \texttt{final} so no one can swap out \texttt{BLACK} for a different colour which would certainly
            confuse people trying to use \texttt{BLACK} afterwards.
        
            Oh, also notice that this \emph{constant} is spelled with all capital letters. This is standard Java naming practice. You
            should use the standard coding conventions of whatever language you are using - it tends to annoy other developers if you don't.
        
            But, now imagine that the \texttt{r}, \texttt{b}, \texttt{g} fields of the \texttt{Colour} object weren't \texttt{final}. Now
            you could change \texttt{BLACK} into red, which probably wouldn't be the best idea:
        
            \begin{minted}[autogobble]{Java}
                Colour.BLACK.r = 1;
            \end{minted}
        
            While we're here, let's make another constructor, this time for gray scale colours. It will only take one value, the amount of
            gray, and will call the other constructor to do it's work.

            \begin{minted}[autogobble]{Java}
                public class Colour {
                    ...
                    public Colour(float c) {
                        this(c, c, c);
                    }
                    ...
                }
            \end{minted}
            
            Did you notice the odd little notation to call another constructor from the same class?
        
            Can you finish off the \texttt{Colour} class? Add more standard colours. Add some error checking so people don't give crazy
            numbers to the constructor.
        
        \newpage
        \paragraph{An \texttt{Image} is made of \texttt{Colour}s}
            %
            Let's go ahead and make the \texttt{Image} class have a single array of \texttt{Colour}s rather than individual channels.
            Actually, why don't you try that before we show you? (Don't look below til you've tried it.)
            
            Now, we'll see that, but I'm going to make a few other changes as well which I'll explain afterwards.
            
            \begin{minted}[autogobble]{Java}
                public class Image {
                    public final int w;
                    public final int h;

                    private final Colour[] pix;

                    public Image(int w, int h) {
                        if(w <= 0) throw new IllegalArgumentException("width must be > 0");
                        if(h <= 0) throw new IllegalArgumentException("width must be > 0");
                        this.w = w;
                        this.h = h;
                        pix = new Colour[w * h];
                        for(int i = 0; i < w * h; ++i) pix[i] = Colour.BLACK;
                    }

                    public void set(int x, int y, Colour c) {
                        if(x < 0 || x >= w || y < 0 || y > h) throw new IllegalArgumentException("Cannot access pixel,"+x+","+y);
                        if(c == null) throw new IllegalArgumentException("Cannot set pixel to null");
                        pix[x + y * w] = c;
                    }
                    public Colour get(int x, int y) {
                        if(x < 0 || x >= w || y < 0 || y > h) throw new IllegalArgumentException("Cannot access pixel,"+x+","+y);
                        return pix[x + y * w];
                    }

                    private int colourToInt(float c) {
                        return (int)(c * 255);
                    }

                    public void write(PrintStream ps) {
                        ps.println("P3");
                        ps.println(w + " " + h);
                        ps.println(255);
        
                        for(Colour p : pix) {
                            ps.print(colourToInt(p.r) + " ");
                            ps.print(colourToInt(p.g) + " ");
                            ps.print(colourToInt(p.b) + " ");
                        }
                    }
    
                    public void write(String fileName) throws FileNotFoundException {
                        PrintStream ps = new PrintStream(fileName);
                        write(ps);
                        ps.close();
                    }
                }
            \end{minted}
        
            What's different here? 
            
            First, I changed the names of \texttt{width} and \texttt{height} to \texttt{w} and \texttt{h}, since we now know we can reuse
            names. This is a pretty pointless change really, but it's good to see where you need to use \texttt{this.w} and \texttt{this.h}.
            
            Then you'll see that the arrays, \texttt{r}, \texttt{b}, and \texttt{g} have been replaced by a single array of
            \texttt{Colour}s, called \texttt{pix}. In the constructor you'll see that gets initialised with \texttt{new}.

            The constructor then fills in each element of \texttt{pix} with \texttt{Colour.BLACK}. That is because a newly created array of
            objects will have each element set to \texttt{null}. We'd much rather the elements had sensible colours to start with.
            
            Now you might also see that the \texttt{pix} array is declared \texttt{private}, not \texttt{public}. This prevents any code
            except that written in the \texttt{Colour} class from messing with the array. If we don't let anyone else change the array,
            then no one can put \texttt{null}s in it which might break our code.
            
            The \texttt{set} method now takes a \texttt{Colour}, rather than individual channels.
            
            Since we have made the \texttt{pix} field private, no one else can access it to write it. But they also can't read it. The
            \texttt{get} method lets people see what's in an image's pixels safely. 
            
            I also changed \texttt{colourToInt} to be \texttt{private} because it's only really for the \texttt{Image} class's internal use.
            
            Finally, I made two versions of \texttt{write}. One works on \texttt{PrintStream}s, the other does the sensible thing with a
            file name. In Java, you can have two methods with the same name if they have different parameter types. Notice that the file
            name version calls the \texttt{PrintStream} version. You can now easily print an image to standard output as well as to files.
            
        \paragraph{Filling an image}
            %
            I had another motivation for wanting use \texttt{Colour} objects rather than three channels. It means that we can return
            colours from a method. This lets us do something cool.
            
            At the moment, you have to set pixels individually or write a couple of nested for loops, iterating over \texttt{x} and
            \texttt{y}.  That latter form is likely to be a common thing to do but it's a bit of pain.  
            
            Suppose we had a type of object with a function that takes an \texttt{Image}, \texttt{x} and \texttt{y} and gives a
            \texttt{Colour}. Maybe it looks like this (put this in a file called \texttt{PixelFn.java}):
        
            \begin{minted}[autogobble]{Java}
                public interface PixelFn {
                    Colour apply(Image img, int x, int y);
                }
            \end{minted}
            
            We could then have a method in our \texttt{Image} class which takes one of these functions and fills in the pixels:

            \begin{minted}[autogobble]{Java}
                public void fill(PixelFn f) {
                    for( int x = 0; x < w; ++x) {
                        for( int y = 0; y < h; ++y) {
                            set(x, y, f.apply(this, x, y));
                        }
                    }
                }
            \end{minted}
            
            That would mean that we could fill an entire image with just one line of code if we had a suitable \texttt{PixelFn}.
            
            But, wait a second! What is all that going on with \texttt{PixelFn}? I said it was a \emph{class}, but it says
            \texttt{interface}. And, the method doesn't have an implementation, and the method isn't \texttt{public}.
            
            An interface is a very special type of type which gets added to other classes to let you share types. We might use it like this:

            \begin{minted}[autogobble]{Java}
                public class Reddish implements PixelFn {
                    public Colour apply(Image img, int x, int y) {
                        return Colour(x/(float)img.w);
                    }
                }
            \end{minted}
            
            This says \texttt{Reddish} is also an PixelFn, so you can use it wherever you would use an \texttt{PixelFn}.

            \begin{minted}[autogobble]{Java}
                public static void main(String[] args) {
                    Image img = new Image(200, 100);
                    img.fill(new Reddish());
                    img.write(System.out);
                }
            \end{minted}
            
            That looks a bit better, but Java has something really cool to make this even better.

        \newpage
        \paragraph{Lambda functions!}
            %
            Java has a pretty cool way of making these little classes which are only used to pass forward a method. They are called
            \emph{lambda}s. They are definitely worth you while Googling about. Here, I'm just going to show you how we can use them, but I
            won't go into too much explanation (you can always ask a helper).
            
            We do two things. The first is to declare that \texttt{PixelFn} is one of these special little classes. Java uses something
            called an \emph{annotation} for this. An annotation just tags a class with some extra information. To do it for
            \texttt{PixelFn}, we add this:
            
            \begin{minted}[autogobble]{Java}
                @FunctionalInterface
                public interface PixelFn {
                    Colour apply(Image img, int x, int y);
                }
            \end{minted}
            
            Now, when we use it in the \texttt{fill} method, we can create an \texttt{PixelFn} with some pretty cool syntax:
            
            \begin{minted}[autogobble]{Java}
                public static void main(String[] args) {
                    Image img = new Image(200, 100);
                    img.fill(
                        (im, x, y) -> new Colour(x/(float)im.w, y/(float)im.h, 0)
                    );
                    img.write(System.out);
                }
            \end{minted}
            
            That bit inside of \texttt{fill} implicitly makes an \texttt{PixelFn} whose \texttt{apply} method makes that \texttt{Colour}.
            It's really quite neat.
            
            Now that we've got this, we can also add another constructor to \texttt{Image}, since often we'd want to fill the image as soon
            as we make it.
            
            \begin{minted}[autogobble]{Java}
                public class Image {
                    ...
                    public Image(int w, int h, PixelFn f) {
                        if(w <= 0) throw new IllegalArgumentException("width must be > 0");
                        if(h <= 0) throw new IllegalArgumentException("width must be > 0");
                        this.w = w;
                        this.h = h;
                        pix = new Colour[w * h];
                        fill(f);
                    }
                    ...
                }
            \end{minted}
            
            Now, that whole thing to make our smooth image becomes:
            
            \begin{minted}[autogobble]{Java}
                import java.io.*;

                public class SmoothLambda {
                    public static void main(String[] args) throws FileNotFoundException {
                        new Image(200, 100, (im, x, y) -> new Colour(x/(float)im.w, y/(float)im.h, 0)).write("smooth.ppm");
                    }
                }
            \end{minted}
        
            BTW, the \texttt{apply} method's name isn't important. The name comes from functional programming terminology.
        
        \newpage
        \paragraph{Windowed fill}
            %
            The images we have drawn are 2d arrays of pixels. But what they represent isn't necessarily pixelated. You may have heard about
            Mandelbrots, for example. They define a 2 dimensional real valued space\footnote{Actually the coordinate system is given by
            complex numbers.}. At each point in the space we can ask what colour that point is. It isn't a discreet space, like the bitmap
            type images we have drawn so far, made up of little squares. Instead you can look as closely or as far away as you like.
            
            So, suppose we have an image function which takes in an \texttt{x} and \texttt{y} both of type \texttt{float} and returns a
            \texttt{Colour}. We want to make the \texttt{Image} bitmap be a little window onto this real valued image function. This isn't
            too different from the \texttt{PixelFn} we had before, except it uses floats and doesn't take the \texttt{Image} as a
            parameter. It shouldn't need the \texttt{Image} since it should never change itself because of the window.
            
            We then like to fill an \texttt{Image} by giving it one of these functions and telling it the rectangle of the window we want
            to look at.  Have a look at the picture below to get the idea.
            
            \includegraphics[width=\textwidth]{code/mandel-window}
            
            The \texttt{Image} we fill will be the little rectangle in the middle. The number of pixels in each dimension are given by the
            \texttt{Image}'s width and height. We can move the rectangle around and `see' different bits of the underlying function.
            Do you think you could add these capabilities to the \texttt{Image} class?  Try it.
            
            
            Let's start by making the \texttt{ImageFn}.  Remember to put this in a file called \texttt{ImageFn.java}.
            
            \begin{minted}[autogobble]{Java}
                @FunctionalInterface
                public interface ImageFn {
                    Colour apply(float x, float y);
                }
            \end{minted}
            
            Now for the \texttt{fill} method, we need to take the \texttt{ImageFn} and the coordinates of the window on the
            \texttt{ImageFn}. We could (and probably should) do that by making a \texttt{Rectangle} class, but for the moment I'll just
            take the values for the \emph{top}, \emph{left}, \emph{bottom}, and \emph{right} of the window individually.
            
            \begin{minted}[autogobble]{Java}
                public class Image {
                    ...
                    public void fill(ImageFn f, float lft, float top, float rgt, float bot ) {
                        for( int x = 0; x < w; ++x) {
                            float fw = rgt - lft;
                            float fx = lft + x * fw / w;
                            for( int y = 0; y < h; ++y) {
                                float fh = bot - top;
                                float fy = top + y * fh / h;
                                set(x, y, f.apply(fx, fy));
                            }
                        }
                    }                    
                    ...
                }
            \end{minted}
            
            The important bit is that we've mapped from the bitmap coordinates, \texttt{x} and \texttt{y}, into the \texttt{ImageFn}
            coordinates, \texttt{fx} and \texttt{fy}\footnote{I'm beginning to think \texttt{BitMap} or something might have been a better
            name than \texttt{Image}. You could always change the names, of course.} Then we called the \texttt{ImageFn}, \texttt{f}, to
            get the colour and set the appropriate pixel in the \texttt{Image}.
            
            We should probably make a constructor like this as well.

            \begin{minted}[autogobble]{Java}
                public class Image {
                    ...
                    public Image(int w, int h, ImageFn f, float lft, float top, float rgt, float bot ) {
                        if(w <= 0) throw new IllegalArgumentException("width must be > 0");
                        if(h <= 0) throw new IllegalArgumentException("width must be > 0");
                        this.w = w;
                        this.h = h;
                        pix = new Colour[w * h];
                        fill(f, lft, top, rgt, bot);
                    }
                    ...
                }
            \end{minted}
            
            Shall we use it? Can you make an ImageFn that represents a filled in red circle of radius one at the origin with black
            elsewhere? Can you then make an \texttt{Image} of that with a suitable window?
            
            Here we go:
            
            \begin{minted}[autogobble]{Java}
                public class CircleTest {
                    public static void main(String[] args) {
                        new Image(
                            200, 200,
                            (x,y) -> x*x + y*y > 1 ? Colour.BLACK : Colour.RED,
                            -1, 1, 1, -1 
                        ).write("circle.ppm");
                    }
                }
            \end{minted}
            
            It should look like this:
            
            \includegraphics[width=0.4\textwidth]{code/circle}
            

            I bet you can come up with a whole bunch of cool things to add to these classes.  You should, give it a go!
            
            But, for the moment, we will stop playing with this and move on to drawing some pretty pictures 

        \newpage
        \paragraph{Other things}
            Here some ideas of things you might try.
            \begin{itemize}
                \item Anti-aliasing - allow supersampling of the \texttt{ImageFn} so that the circle doesn't get so jaggy.
                \item What about having an alpha channel (transparency).
                \item Can you make transforms from one image to another.  E.g. grayscale, colour shift, scale, rotate, etc?
                \item Can you make methods to compose images?
                \item There is also a P6 version of PPM which is more compact, it uses binary.  Can you use that instead?
                \item Can you write directly to a different file format?
                \item Skip this lot and look at how Java supports images.
                \item Can you make a GUI to show moving images?
                \item Can you do the same thing in HTML, using JavaScript and an HTML Canvas object?
            \end{itemize}

    \newpage
    \section{Mandelbrots}

        We're going to make a very famous type of fractal called a Mandelbrot. The Mandelbrot set is those complex points, $c$, for which
        $f_c(z)=z^2+c$ does not diverge when iterated. What that means is that if you view a complex number as a point on a 2 dimensional
        plane -- the real component is the \texttt{x} axis, and the imaginary component is the \texttt{y} axis -- then we can tell whether
        that point is in the set by repeatedly applying that equation forever and seeing if it grows without bound or not.
        
        Well, obviously doing things for ever is a tiny bit tedious. So instead what we'll do is repeat the equation a maximum number of
        times and see if the complex number gets bigger than some threshold in that time.  This is called the escape time algorithm.
        
        In fact, some numbers `escape' more quickly than others, so we can use that `speed of escape' to assign a colour to the points
        which aren't in the set.
        
        That is, for a given point, $c$, start with 
        
        $$z_0 = 0$$
        $$z_n = z_{n-1}^2 + c$$
        
        Now iterate and find out the first $n$ for which $|z_n| > 2$ or $n > 32$ (the latter bit stops you going on forever). You can
        change the 2 and the 32 if you like.
        
        This gives you number, $n$, in the interval, $[0,32]$. You can convert this number into a colour, making 0 black, 32 white, and
        interpolating in between.
        
        Now imagine your image ranges over the complex space, with the x axis ranging from -2 to 1, and the y axis ranging from
        -1.5\emph{i} to 1.5\emph{i}. You can now plot the Mandelbrot set for this part of the space. It should look like this:
        
        \begin{center}
            \includegraphics[width=0.4\textwidth]{../latex-src/mandelbrot}
        \end{center}
        
        Have a go at doing this yourself, then I'll walk you through my solution.
        
        \newpage
        \paragraph{Complex numbers, a reminder}
            %
            It's pretty clear we're going to need complex numbers here. Unfortunately, Java doesn't provide them out of the box. There are
            a bunch of online implementations - maybe you could search for some. But we also should have learned enough to be able to make
            our own. Let's do that.
            
            A quick reminder about what complex numbers are.
            
            A complex number has a real and imaginary component: 
            $$z = a + bi$$
            Where $i$ is the imaginary square root of $-1$.
            
            We can extract those components in some mathematical notation: 
            $$z = a + bi \rightarrow re(z) = a$$
            $$z = a + bi \rightarrow im(z) = b$$
            
            
            We can add and multiply complex numbers (parentheses are just make doubly clear which bits are real and imaginary):
            $$z_1 = a_1 + b_1i, z_2 = a_2 + b_2i \rightarrow z_1 + z_2 = (a_1 + a_2) + (b_1 + b_2)i$$
            $$z_1 = a_1 + b_1i, z_2 = a_2 + b_2i \rightarrow z_1   z_2 = (a_1   a_2 - b_1   b_2) + (a_1   b_2 + b_1   a_2)i$$

            This let's us square a number:
            $$z = a + bi \rightarrow z^2 = (a^2 - b^2) + 2abi$$

            We can also ask the magnitude of a complex number:
            $$z = a + bi \rightarrow |z| = \sqrt{a^2 + b^2}$$
            
            That should give us everything we need to implement a complex number class.
        
        \paragraph{\texttt{Complex} class}
            %
            Let's make a file called \texttt{Complex.java} and put our class in it. Like \texttt{Colour}, we'll make it \emph{immutable}
            for safety. Can you make the right fields and constructors\footnote{Uggh, why doesn't Java allow default arguments in
            constructors? This is why I hate this language. One of the reasons, anyway.}?
            
            \begin{minted}[autogobble]{Java}
                public class Complex {
                    public final float re;
                    public final float im;
                    
                    public Complex(float re, float im) {
                        this.re = re;
                        this.im = im;
                    }
                    public Complex(float re) {
                        this(re, 0);
                    }
                }
            \end{minted}
            
            What about the other operations? Magnitude is easy. 

            But let's also have a method called \texttt{magSq} which will give us the magnitude squared. Why? Well, often you can avoid
            doing the expensive square root operation. Consider the check we will need to do to find out if our magnitude is greater than
            2. Instead we could check if the squared magnitude is greater than 4. No square root required.

            \begin{minted}[autogobble]{Java}
                public class Complex {
                    ...
                    public float magSq() {
                        return re * re + im * im; 
                    }
                    public float mag() {
                        return (float)Math.sqrt(magSq());
                    }
                    ...
            \end{minted}
            
            Did you notice that we had to cast the \texttt{double} result from \texttt{Math.sqrt} into the smaller \texttt{float}?
            
            There are different ways we could do the add and multiply. We could have a \texttt{static} method which takes two complex
            numbers, or we could have an instance member which takes the other number to use. Or we can have both and let the user decide
            which to use. Neither are going to look as good as languages which allow operator overloading, but we can't help that in Java.
            
            \begin{minted}[autogobble]{Java}
                public class Complex {
                    ...
                    public static Complex add(Complex a, Complex b) {
                        return new Complex(a.re + b.re, a.im + b.im);
                    }
                    public Complex add(Complex that) {
                        return add(this, that);
                    }
                    public static Complex mul(Complex a, Complex b) {
                        return new Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);
                    }
                    public Complex mul(Complex that) {
                        return mul(this, that);
                    }
                    ...
            \end{minted}
            
            Oh, we can add some constants, too.
            
            \begin{minted}[autogobble]{Java}
                public class Complex {
                    ...
                    public static final Complex ZERO = new Complex(0);
                    public static final Complex ONE = new Complex(1);
                    public static final Complex I = new Complex(0, 1);
                    ...
            \end{minted}
                    
        \paragraph{The Mandelbrot escape function}
            %
            Now we are ready to make our escape function. Can you do it? It should take a complex point and tell you how long it takes to
            escape.
            
            We can make a \texttt{Mandelbrot} class. This should take our escape threshold and maximum iterations as parameters to
            the constructor. Then we'll have an \texttt{escapeTime} function which does the actual calculation.
            
            \begin{minted}[autogobble]{Java}
                public class Mandelbrot {
                    public final float threshold;
                    public final int maxIter;
                    
                    public Mandelbrot(float threshold, int maxIter) {
                        this.threshold = threshold;
                        this.maxIter = maxIter;
                    }
            
                    public int escapeTime(Complex c) {
                        Complex z = Complex.ZERO;
                        int n = 0;
                        float thresSq = threshold * threshold;
                        while(n < maxIter && z.magSq() < thresSq) {
                            z = z.mul(z).add(c); 
                            n++;
                        }
                        return n;
                    }
                }
            \end{minted}
        
        \newpage
        \paragraph{Colour mapping}
            %
            We need to map from the escape count to a colour. There are lots of ways we might do this, but we said we'd at least start by
            doing it in grayscale.  Can you make a class to do that for you?
            
            Now, I'm going to make this class map floating point numbers from a range into colours. Really I'm just doing this because
            maybe it might be useful later. 
            
            Hmm, maybe we should make an interface for colour mapping so that we could have different colour maps?
            \begin{minted}[autogobble]{Java}
                @FunctionalInterface
                public interface ColourMap {
                    Colour apply(float x);
                }
            \end{minted}
            
            Now, our gray colour map is:
            
            \begin{minted}[autogobble]{Java}
                public class GrayColourMap implements ColourMap {
                    public final float min;
                    public final float max;
                    
                    public GrayColourMap(float min, float max) {
                        this.min = min;
                        this.max = max;
                    }
                    public Colour apply(float x) {
                        float g = (x - min) / (max - min);
                        return new Colour(g);
                    }
                }
            \end{minted}
            
        \paragraph{Making the image}
            %
            We're almost there.  Let's make the \texttt{Image}. Can you see how to do this?
            
            We'll add to our \texttt{Mandelbrot} class:
            
            \begin{minted}[autogobble]{Java}
                public class Mandelbrot {
                    ...
                    public void fill(Image img, float lft, float top, float rgt, float bot, ColourMap colours ) {
                        img.fill(
                            (x, y) -> colours.apply(escapeTime(new Complex(x, y))),
                            lft, top, rgt, bot
                        );
                    }
                }
            \end{minted}
            
            Now we can put a \texttt{main} method to create the image, fill it, and write it to a file:
            \begin{minted}[autogobble]{Java}
                public class Mandelbrot {
                    ...
                    public static void main(String[] args) throws FileNotFoundException {
                        Mandelbrot mandelbrot = new Mandelbrot(2, 32);
                        ColourMap colours = new GrayColourMap(0,32);
                        Image img = new Image(400, 400);
                        mandelbrot.fill(
                            img, 
                            -2, 1.5f, 1, -1.5f, 
                            colours
                        );
                        img.write("mandel.ppm");
                    }
                }
            \end{minted}
            
            This should give us the image we were aiming for earlier.
            
            \newpage
            We could use a different colour map to get funkier colours. Here's one I did with some different colours, a higher max
            iteration count and a finer resolution, oh and I used a continuous colouring. That last bit is in the list of other things
            below that might interest you (but I solve it later for you anyway).
            
            \includegraphics[width=0.8\textwidth]{code/mandel}
            
            Change the parameters and have a zoom about.
        
        \paragraph{Other things}
            Here some ideas of things you might try (or move on to the next fractal).
            \begin{itemize}
                \item It is really slow for big images. What solutions have people come up with? Try some?
                \item Try histogram colouring
                \item Try continuous colouring
                \item Do Multibrots - $z_n = z_{n-1}^d + c$, for some $d$
                \item Try contour or border mapping
                \item How do you go beyond 32 or 64 bit precision?
                \item Try showing Julia sets
            \end{itemize}
            
            Here's a question for you. We've used \texttt{float}s so far. What are the advantages or disadvantages compared to
            \texttt{double}s? Certainly, you can zoom in more if you use \texttt{double}s. Should you refactor all the \texttt{float}s into
            \texttt{double}s? Yes, probably. Does it change the performance on your machine? What does it do to the memory consumption?
    
    \newpage
    \section{A JavaFX Gui}
        Okay, I thought we could try something a bit different.  Shall we make a very simple GUI for our Mandelbrot pictures?  Yes?  Good.
        
        Right. Well, the first thing I should admit to you is that I haven't made a GUI for anything in Java for about 15 years. I have
        just been looking at what's there and it has all changed, almost beyond all recognition. So, we're going to have work this out
        together. And, when I show you some code for how to do things, realise that you can probably do better yourself. If you do write
        some better code, send me an email and I can update this project.
        
        The next thing I'm going to tell you is that a bunch of the stuff we wrote before is going to be wasted because Java already did
        them for you. Oh well, hopefully you learned something while doing it, though, right? For example, there is already a very good
        \texttt{Color} class, and there is already a pretty good \texttt{Image} class. We're going to throw ours away and use Java's. We'll
        make a new project (if you're using an IDE like Eclipse), or a new directory for our code (if you're doing it old school).
        
        Java still doesn't have a \texttt{Complex} class, so we can copy that over. But, while you're at it, make this version use only
        \texttt{double}s, not floats.
        
        We're going to be using \emph{JavaFX}, which is Java's new graphics and GUI APIs. You will be able to find lots of tutorials and
        things online as well as the raw API documentation. I'm only going to show you the bits we need for our simple user interface, but
        you should definitely check out other resources.
        
        Here's a bit for you. From now on, we'll use JavaFX's \texttt{Color} class. You can find it at:
        \url{https://docs.oracle.com/javase/9/docs/api/javafx/scene/paint/Color.html}. Have a look at, see the similarities and differences
        between it and the simpler version we made. For the most part, it's similar enough that we don't need to discuss it too much.
        
        There's also an \texttt{Image} class, here: \url{https://docs.oracle.com/javase/9/docs/api/javafx/scene/image/Image.html}. It's a
        bit different from ours. The basic class let's you load an image of various types from a file and scale it, etc. But, we're not
        very interested in that. How do you read and write pixels?
        
        For reading you ask the \texttt{Image} for a \texttt{PixelReader} using the \texttt{getPixelReader()} method. A
        \texttt{PixelReader} can then get you the \texttt{Color} for a pixel. The \texttt{PixelReader} interface is given here:
        \url{https://docs.oracle.com/javase/9/docs/api/javafx/scene/image/PixelReader.html}.
        
        But there doesn't seem to be anyway to set the pixels in an \texttt{Image}, right? Right. There isn't. In fact, we need a different
        class in the same package, \texttt{WritableImage} --
        \url{https://docs.oracle.com/javase/9/docs/api/javafx/scene/image/WritableImage.html}. A \texttt{WritableImage} is actually a
        subclass of \texttt{Image}, which means that everything you can do with an \texttt{Image}, you can do to a \texttt{WritableImage}.
        A \texttt{WritableImage} has a method, \texttt{getPixelWriter()}, which gives you a \texttt{PixelWriter},
        \url{https://docs.oracle.com/javase/9/docs/api/javafx/scene/image/PixelWriter.html}, that lets you actually set the pixels. Why is
        it this complicated?

        \paragraph{A first JavaFX image}
            %
            So, let's create an \texttt{Image} programmatically. We'll make an image that is 200 by 100 pixels and we'll set the pixels in
            the way we did for the smooth image before.
        
            \begin{minted}[autogobble]{Java}
                import javafx.scene.image.WritableImage;
                import javafx.scene.image.PixelWriter;
                import javafx.scene.paint.Color;

                public class ImageTest {
                    public static void main(String[] args) {
                        WritableImage img = new WritableImage(200, 100);
                        PixelWriter pw = img.getPixelWriter();
        
                        // Set the pixels
                        for(int x = 0; x < img.getWidth(); ++x) {
                            for(int y = 0; y < img.getHeight(); ++y) {
                                Color c = Colour.color(x/img.getWidth(), 0, y/img.getHeight());
                                img.setColor(x, y, c);
                            }
                        }
                    }
                }
            \end{minted}
        
            BTW, note that there's something a bit weird going on with the width and height of \texttt{Image}s. You create a
            \texttt{WritableImage} using integer width and height. But when you ask for the width and height afterwards using
            \texttt{getWidth()} and \texttt{getHeight()}, the answers are \texttt{double}s!

        \newpage
        \paragraph{Writing a JavaFX image to disk} 
            %
            Great. But how on earth do we view it? Before we go on to making a GUI, we'll work out how to write an image to a file. This is
            going to be a little bit painful because the \texttt{Image} doesn't support it natively. We're actually going to convert the
            \texttt{Image} into an older API, and then use that to write out the image to disk.
        
            We'll make a class to hold this, and any other, image utilities.  Let's call it \texttt{ImageUtil}.
        
            What we do is use \texttt{SwingFXUtils}, \url{https://docs.oracle.com/javase/9/docs/api/javafx/embed/swing/SwingFXUtils.html},
            to convert the image to a \texttt{BufferedImage},
            \url{https://docs.oracle.com/javase/9/docs/api/java/awt/image/BufferedImage.html}, then use \texttt{ImageIO},
            \url{https://docs.oracle.com/javase/9/docs/api/javax/imageio/ImageIO.html}, to write that image out. Uggh, what a palaver!
            Hopefully, though, once we have the code for it once we won't ever have to worry about it again, we can just use our
            \texttt{ImageUtil} class.
        
            \begin{minted}[autogobble]{Java}
                import java.awt.image.BufferedImage;
                import java.io.File;
                import java.io.IOException;
                import javafx.embed.swing.SwingFXUtils;
                import javafx.scene.image.Image;
                import javax.imageio.ImageIO;

                public class ImageUtil {
                    public static void write(Image img, File file) throws IOException {
                        BufferedImage swingImg = SwingFXUtils.fromFXImage(img, null);
                        String type;
                        String fileName = file.getName();
                        int lastDot = fileName.lastIndexOf(".");
                        if(lastDot == -1) type = "png";
                        else type = fileName.substring(lastDot + 1);
                        ImageIO.write(swingImg, type, file);
                    }
                }
            \end{minted}
        
            Note that here I get the type of the image from the extension of the file name, or uses ``png''. I haven't tried other types.
            You might consider how to make this more robust.
        
            Now we should be able to update our \texttt{ImageTest} class to write out the image for us:
            
            \begin{minted}[autogobble]{Java}
                import java.io.*;
                ...
                public class ImageTest {
                    ...
                    public static void main(String[] args) throws IOException {
                        ...
                        ImageUtil.write(img, new File("smooth.png"));
                    }
                }
            \end{minted}
        
        \paragraph{Filling an image}
            %
            Maybe we quite liked our previous ability to fill an image just from a function. Let's replicate that ability here.
            
            First, we'll make two versions of colour functions. One for mapping a 1-d input to a colour and one for mapping a 2-d input to
            a colour.

            Here's the one dimensional version:
            \begin{minted}[autogobble]{Java}
                import javafx.scene.paint.Color;
                
                @FunctionalInterface
                public interface ColorMap1d {
                    public Color apply(double x);
                }
            \end{minted}

            Here's the two dimensional version:
            \begin{minted}[autogobble]{Java}
                import javafx.scene.paint.Color;
                
                @FunctionalInterface
                public interface ColorMap2d {
                    public Color apply(double x, double y);
                }
            \end{minted}
            
            Now, we can make a \texttt{fill} method in \texttt{ImageUtil}. Oh, and we can make use of the \texttt{Rectangle2D} class that
            JavaFX gives us, \url{https://docs.oracle.com/javase/9/docs/api/javafx/geometry/Rectangle2D.html}.
            
            \begin{minted}[autogobble]{Java}
                ...
                import javafx.geometry.Rectangle2D;
                
                public class ImageUtil {
                    public static void fill(WritableImage img, ColorMap2d f, Rectangle2D port) {
                        PixelWriter pw = img.getPixelWriter();

                        double iw = img.getWidth();
                        double ih = img.getHeight();
        
                        double fminx = port.getMinX();
                        double fminy = port.getMinY();
                        double fw = port.getWidth();
                        double fh = port.getHeight();
        
                        for(int ix = 0; ix < iw; ++ix) {            
                            double fx = fminx + ix * fw / iw;
            
                            for(int iy = 0; iy < ih; ++iy) {
                                double fy = fminy + iy * fh / ih;

                                pw.setColor(ix, iy, f.apply(fx, fy));
                            }
                        }
                    }
                    ...
                }
            \end{minted}
            
            The code is basically the same as the code that we had before, just converted to use our new classes.

            Let's add a convenience method to \texttt{ImageUtil} to create a new image directly from a \texttt{ColorMap2d}, rather than
            needing us to supply it.
            
            \begin{minted}[autogobble]{Java}
                ...
                public class ImageUtil {
                    public static WritableImage image(int w, int h, ColorMap2d f, Rectangle2D port) {
                        WritableImage img = new WritableImage(w, h);
                        ImageUtil.fill(img, f, port);
                        return img;
                    }
                    ...
                }
            \end{minted}

            And now the \texttt{main} method of our \texttt{ImageTest} class can be replaced with:
            
            \begin{minted}[autogobble]{Java}
                import javafx.geometry.Rectangle2D;
                ...
                public class ImageTest {
                    ...
                    public static void main(String[] args) throws IOException {
                        WritableImage img = ImageUtil.image(
                            200, 100,
                            (x, y) -> Color.color(x, 0, y),
                            new Rectangle2D(0, 0, 1, 1)
                        );
                        ImageUtil.write(img, new File("smooth.png"));
                    }
                }
            \end{minted}
            
            Great. We're pretty much back to where we started. Why didn't we just do this from the start?
            
        \paragraph{An image in a window}
            %
            We are at the point where we can put an image in a window.
            
            Let's make a class called \texttt{SoothApp}. Now, I'm about as new to JavaFX as you are, so my explanation of this might be a
            bit hokey. 
            
            There is an \texttt{Application} class, \url{https://docs.oracle.com/javase/9/docs/api/javafx/application/Application.html},
            which manages the lifecycle of the application. Specifically for us, this means we have a method we can fill in that the system
            will call when the application starts. That method is called, wait for it ..., \texttt{start}. This takes a \texttt{Stage}
            object, \url{https://docs.oracle.com/javase/9/docs/api/javafx/stage/Stage.html}, which you can think of as the window (it is
            literally a subclass of \texttt{Window}, \url{https://docs.oracle.com/javase/9/docs/api/javafx/stage/Window.html}). The
            \texttt{Stage} needs a \texttt{Scene}, \url{https://docs.oracle.com/javase/9/docs/api/javafx/scene/Scene.html}, which describes
            what's in the window. The \texttt{Scene} in turn needs a set of things to show inside it. These things are given different
            default layouts. Probably the simplest is \texttt{Pane},
            \url{https://docs.oracle.com/javase/9/docs/api/javafx/scene/layout/Pane.html}. Into a \texttt{Pane} we can put a \texttt{Node}
            that knows how to render our \texttt{Image}. This \texttt{Node} is called an \texttt{ImageView},
            \url{https://docs.oracle.com/javase/9/docs/api/javafx/scene/image/ImageView.html}.
            
            Finally, you \texttt{launch} the \texttt{Application} from \texttt{main}.
            
            That all sounds a bit complicated.  It might not look so bad once you see the code:
            
            \begin{minted}[autogobble]{Java}            
                import javafx.application.*;
                import javafx.geometry.Rectangle2D;
                import javafx.scene.*;
                import javafx.scene.layout.*;
                import javafx.scene.image.*;
                import javafx.scene.paint.*;
                import javafx.stage.*;

                public class SmoothApp extends Application {
                    public void start(Stage stage) {
                        WritableImage img = ImageUtil.image(
                            200, 100,
                            (x, y) -> Color.color(x, 0, y),
                            new Rectangle2D(0, 0, 1, 1)
                        );
        
                        ImageView iv = new ImageView(img);
                        Pane root = new Pane(iv);
                        Scene scene = new Scene(root, img.getWidth(), img.getHeight());

                        stage.setTitle("Smooth!");
                        stage.setScene(scene);
                        stage.setResizable(false);
                        stage.show();
                    }

                    public static void main(String[] args) {
                        launch(args);
                    }
                }
            \end{minted}
        
        \newpage
        \paragraph{A Mandelbrot GUI}
            %
            Can you make a Mandelbrot show up in a GUI?
            
            Okay, I'll show you a way. We're going to make a bunch of classes, some of which are very close to things you've done before so
            won't get discussed much.
            
            First up, let's have some better colours than just gray.  Here's a multi color one that cycles through a bunch of colours:
            
            \begin{minted}[autogobble]{Java}            
                public class MultiColorMap1d implements ColorMap1d {
                    public final double min;
                    public final double max;
                    public MultiColorMap1d (double min, double max) {
                        this.min = min;
                        this.max = max;
                    }
                    public Color apply(double x) {
                        double s = Math.PI * (x - min) / (max - min);
                        return Color.color(
                            Math.abs(Math.sin(s*40)), 
                            Math.abs(Math.sin(s*60)), 
                            Math.abs(Math.cos(s*40))
                        );
                    }
                }
            \end{minted}
        
            \newpage
            Then let's make our \texttt{Mandelbrot} class, much like before. But, I've made it all use \texttt{double}s and also I've added
            a \texttt{smoothEscape} function (which you can find out more about here:
            \url{https://en.wikipedia.org/wiki/Mandelbrot_set#Continuous_(smooth)_coloring}, I stole their implementation).
            
            \begin{minted}[autogobble]{Java}            
                class Mandelbrot {
                    public final double threshold;
                    public final int maxIter;
    
                    public Mandelbrot(double threshold, int maxIter) {
                        this.threshold = threshold;
                        this.maxIter = maxIter;
                    }

                    public int escapeTime(Complex c) {
                        Complex z = Complex.ZERO;
                        int n = 0;
                        double thresSq = threshold * threshold;
                        while(n < maxIter && z.magSq() < thresSq) {
                            z = z.mul(z).add(c); 
                            n++;
                        }
                        return n;
                    }
                    public double escapeSmooth(Complex c) {
                        Complex z = Complex.ZERO;
                        int n = 0;
                        double thresSq = threshold * threshold;
                        while(n < maxIter && z.magSq() < thresSq) {
                            z = z.mul(z).add(c); 
                            n++;
                        }
                        double iter = n;
                        double log2 = Math.log(2);
                        if(iter < maxIter) {
                            // sqrt of inner term removed using log simplification rules.
                            double log_zn = Math.log(z.magSq( )) / 2;
                            double nu = Math.log(log_zn / log2) / log2;
                            // Rearranging the potential function.
                            // Dividing log_zn by log(2) instead of log(N = 1<<8)
                            // because we want the entire palette to range from the
                            // center to radius 2, NOT our bailout radius.
                            iter = iter + 1 - nu;
                        }
                        return iter;
                    }
                }
            \end{minted}
            
            \newpage
            Now I'm going to make a \texttt{ColorMap2d} from that by making a class that derives from \texttt{Mandelbrot}.
        
            This class is a \texttt{Mandelbrot} and also a \texttt{ColorMap2d}. That is declared on the line which says \texttt{extends}
            and \texttt{implements}. You \texttt{extend} the \emph{single} super class, but you can \texttt{implement} as many
            \emph{interfaces} as you like.
            
            We'll also see here that the constructor calls \texttt{super()}. Rather like before where we could call a different constructor
            in our class using \texttt{this()}, we can call a constructor from the parent class using \texttt{super()}.
        
            \begin{minted}[autogobble]{Java}            
                public class MandelbrotSmoothMap extends Mandelbrot implements ColorMap2d {
                    public final ColorMap1d map;
    
                    public MandelbrotSmoothMap(double threshold, int maxIter, ColorMap1d map) {
                        super(threshold, maxIter);
                        this.map = map;
                    }
    
                    public Color apply(double x, double y) {
                        return map.apply(escapeSmooth(new Complex(x, y)));
                    }
                }
            \end{minted}
            
            Finally, our \texttt{Application} class is quite straightforward.
            
            \begin{minted}[autogobble]{Java}            
                public class MandelbrotApp extends Application {
                    public void start(Stage stage) {
                        int maxIter = 1000;
                        WritableImage img = ImageUtil.image(
                            500, 500,
                            new MandelbrotSmoothMap(1 << 16, maxIter, new MultiColorMap1d(0, maxIter)),
                            new Rectangle2D(-2, -1.5, 3, 3)
                        );
        
                        ImageView iv = new ImageView(img);
                        Pane root = new Pane(iv);
                        Scene scene = new Scene(root, img.getWidth(), img.getHeight());

                        stage.setTitle("Mandelbrot");
                        stage.setScene(scene);
                        stage.setResizable(false);
                        stage.show();
                    }

                    public static void main(String[] args) {
                        launch(args);
                    }
                }
            \end{minted}
        
            If all has gone well, you should get a window with your pretty picture inside it!
            
            Hopefully, you are now thinking of a million things you would like to explore with this.  Please, go do those things!
        
        \newpage
        \paragraph{Zooming in}
            %
            I'll do one more thing with this Mandelbrot.  We'll zoom in when the user double clicks.
            
            First, let's see how we can trap mouse clicks on the image. JavaFX makes this super easy. We add an \texttt{EventHandler} for
            \texttt{MouseEvent}s to the \texttt{onMouseClicked} event handler list. Umm, that's much easier than it sounds:
                        
            \begin{minted}[autogobble]{Java}
                ... 
                public class MandelbrotApp extends Application {
                    public void start(Stage stage) {
                        ...
                        ImageView iv = new ImageView(img);
                        iv.setOnMouseClicked(e -> System.out.println("Clicked at x=" + e.getX() + " y = " + e.getY());
                        ...
                    }
                    ...
                }
            \end{minted}
            
            Hmm, maybe you can work out how zoom in now? If you write to the image inside the event handler, it will update the image. Give
            it a try!
            
            Okay, I'll do it, too. I'll make a \texttt{zoom} function to work out how the \texttt{port} should change. It's fairly simple.
            It takes the current port, the dimensions of the image, and the click point. It returns the new port.
            
                        
            \begin{minted}[autogobble]{Java}
                ... 
                public class MandelbrotApp extends Application {
                    ...
                    private Rectangle2D zoom(Rectangle2D port, double iw, double ih, double ex, double ey) {
                        double w = port.getWidth();
                        double h = port.getHeight();
        
                        // Where was clicked in the image space
                        double x = port.getMinX() + w * ex / iw;
                        double y = port.getMinY() + h * ey / ih;
        
                        // Make the port smaller
                        w *= 0.5;
                        h *= 0.5;

                        // Center around the clicked point
                        return new Rectangle2D(x - w / 2, y - h / 2, w, h);
                    }
                    ...
                }
            \end{minted}
            
            Not too bad. Why did I say it was private? Well, just because I don't really want any other classes messing with it.
            
            Now we just need to make the click handler zoom and fill, right?
            
            \begin{minted}[autogobble]{Java}
                iv.setOnMouseClicked(
                    e -> {
                        port = zoom(port, img.getWidth(), img.getHeight(), e.getX(), e.getY());
                        ImageUtil.fill(img, map, port);
                    }
                );
            \end{minted}

            \newpage
            Umm, ooops. Something badly wrong happened there. Can you work out what?
            
            It isn't the braces or multiple statements in the lambda function. Those are fine.
            
            To understand, we have to remember what happens to the lambda function. It is really just giving the implementation of the
            \texttt{handle} method in a \texttt{EventHandler} class
            (\url{https://docs.oracle.com/javase/9/docs/api/javafx/event/EventHandler.html}) that is implicitly created. The lambda is
            syntactic sugar. It as if we wrote something like:
            
            \begin{minted}[autogobble]{Java}
                class ZoomClickHandler implements EventHandler<MouseEvent> {
                    Rectangle2D port;
                    WritableImage img;
                    ColorMap2d map;
                    
                    public ZoomClickHandler(Rectangle2D port, WritableImage img, ColorMap2d map) {
                        this.port = port;
                        this.img = img;
                        this.map = map;
                    }
                    public void	handle(MouseEvent e) {
                        port = zoom(port, img.getWidth(), img.getHeight(), e.getX(), e.getY());
                        ImageUtil.fill(img, map, port);
                    }
                }
            \end{minted}
            
            And then added the event handler:

            \begin{minted}[autogobble]{Java}
                iv.setOnMouseClicked(new ZoomClickHandler(port, img, map));
            \end{minted}
            
            But look what happens. The local variables have been copied. When we assign to \texttt{port}, it affects the copy, not the
            original. Java assumes this is because we messed up (though actually it would be fine here, Java just doesn't know that). So it
            insists that the only local variables from the parent function you are allowed to access must be marked final so you know they
            can't change. Yes, Java thinks we are idiots.
            
            But we can't mark \texttt{port} as final because we need to change it. Uggh.
            
            As a dirty hack, we could just throw a bunch of stuff up a level into the object's fields so they aren't local anymore.
            
            \begin{minted}[autogobble]{Java}
                public class MandelbrotApp extends Application {
                    private int maxIter = 1000;
                    private ColorMap2d map = new MandelbrotSmoothMap(1 << 16, maxIter, new MultiColorMap1d(0, maxIter));
                    private Rectangle2D port = new Rectangle2D(-2, -1.5, 3, 3);
                    private WritableImage img = ImageUtil.image(500, 500, map, port);
            \end{minted}
            
            Or you could make a proper zoom click handler. Or do it properly some other way.  Up to you.
            
            But now you should have zoomable Mandelbrot!  What else can you add to it?

    \newpage
    \section{Brownian Trees}
        Coming soon...
        
\end{document}
